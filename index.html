

<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>ESP3D WebUI</title>
<style>
* {
  box-sizing: border-box;
}

/* Create three equal columns that floats next to each other */
.column {
  float: left;
  width: 33.33%;
  padding: 10px;
}

@media screen and (max-width: 768px) {
    .column{ float: none; width: 100%; }
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}
.input {
  border-radius: 10px;
  outline: 2px solid #FEBF00;
  border: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  background-color: #e2e2e2;
  outline-offset: 3px;
  padding: 10px 1rem;
  transition: 0.25s;
  box-shadow: 0px 0px 10px white;
}

.input:focus {
  outline-offset: 5px;
  background-color: #fff
}

/* From Uiverse.io by ShrinilDhorda */ 
.btn {
  font-size: 0.8rem;
  padding: 10px 1rem;
  border-radius: 10px;
  cursor: pointer;
  text-transform: uppercase;
  background-color: rgb(14, 14, 26);
  color: rgb(234, 234, 234);
  transition: 0.6s;
  outline: 2px solid white;
  box-shadow: 0px 0px 20px white;
}



.btn:active {
  scale: 0.92;
}

.btn:hover {
  background: rgb(2,29,78);
  background: linear-gradient(270deg, rgba(2, 29, 78, 0.681) 0%, rgba(31, 215, 232, 0.873) 60%);
  color: rgb(4, 4, 38);
}


.btn1 {
  font-size: 0.8rem;
  padding: 10px 1rem;
  border-radius: 10px;
  text-transform: uppercase;
  background-color: rgb(14, 14, 26);
  color: rgb(234, 234, 234);
  transition: 0.6s;
    outline: 2px solid #FEBF00;
  box-shadow: 0px 0px 20px white;
}



.btn1:active {
  scale: 0.92;
}


/* From Uiverse.io by PriyanshuGupta28 */ 
.slider {
  -webkit-appearance: none;
  width: 100%;
  height: 10px;
  border-radius: 5px;
  background-color: #4158D0;
  background-image: linear-gradient(43deg, #4158D0 0%, #C850C0 46%, #FFCC70 100%);
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: #4c00ff;
  background-image: linear-gradient(160deg, #4900f5 0%, #80D0C7 100%);
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: #0093E9;
  background-image: linear-gradient(160deg, #0093E9 0%, #80D0C7 100%);
  cursor: pointer;
}

/* From Uiverse.io by adamgiebl */ 
.cyberpunk-checkbox {
  appearance: none;
  width: 20px;
  height: 20px;
  border: 2px solid #30cfd0;
  border-radius: 5px;
  background-color: transparent;
  display: inline-block;
  position: relative;
  margin-right: 10px;
  cursor: pointer;
}

.cyberpunk-checkbox:before {
  content: "";
  background-color: #30cfd0;
  display: block;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 10px;
  height: 10px;
  border-radius: 3px;
  transition: all 0.3s ease-in-out;
}

.cyberpunk-checkbox:checked:before {
  transform: translate(-50%, -50%) scale(1);
}

.cyberpunk-checkbox-label {
  font-size: 18px;
  color: #fff;
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
}


</style>
</head>
<body style="background-color:#400000;color:white;">

<!--Your text <input onchange="my()" type="text" id="litera">-->
<button class="btn" onclick="my()"  style="display:none">>atopng</button>

<textarea id="textarea" name="w3review" rows="4" cols="50" style="display:none" >data:application/octet-stream;base64,AAEAAAATAQAABAAwR1BPU67NxKYAAQakAAAByEdTVUIAGQAMAAEIbAAAABBMVFNIk+2YHgAABPQAAAC7T1MvMmZbFjUAAAG4AAAAYFZETVhlJWyQAAAFsAAABeBjbWFwxG7jewAAHHwAAAXGY3Z0IAD3A8cAACR0AAAAImZwZ20GWZw3AAAiRAAAAXNnbHlmxrbWHAAAJJgAANewaGRteCQ8giUAAAuQAAAQ7GhlYWQfae95AAABPAAAADZoaGVhBvkCTgAAAXQAAAAkaG10eEtf+w8AAAIYAAAC3Gtlcm4IqgnKAAD9uAAAAhBsb2Nhfne0ugAA/EgAAAFwbWF4cALQBNoAAAGYAAAAIG5hbWVc/5TFAAD/yAAABUBwb3N06+bAEgABBQgAAAGacHJlcFp2Oz8AACO4AAAAugABAAAAAQAAnfVwbV8PPPUAGQPoAAAAAN4aViYAAAAA3hpWSf7O/ngFOgOsAAAACQACAAAAAAAAAAEAAALu/wYAAATe/s79sgU6AAEAAAAAAAAAAAAAAAAAAAC3AAEAAAC3AOgABwD0AAUAAQAAAAAACgAAAgAC/AACAAEAAwHRAZAABQAEArwCigAAAIwCvAKKAAAB3QAyAPoAAAAAAAAAAAAAAACAAAAnQAAASgAAAAAAAAAAT0NUIABAAAD7AgLu/wYAAAOsAYgAAAABAAAAAAF8AyIAAAAgAAIAxwAAAAAAAADHAAAAxwAAAkEAEgKTABwDWwAXA5kAGQFwAB0C9wAVAw8AEwJwACoEcwAYA40AFwLuACADOAASAtMAIAM4ABwDHQAVAuEAHAOYABsC/wAcBE8AIQK2ABYDawAbA6AAHwFB/9UBRP/bAPn/0wFf/9IA8//TAJX/JwE+/5IBQP/UAIn/0ACJ/s4BSf/VAL//5wG9/9ABSf/XAQH/3wE6/5EBQP/QANX/6wDF/7UApf/eATL/2gDq/+IBc//RAPv/vQEp/4YBBv8EA/kAFQGGAAYA4AAGAeAABwHTAAMBlgADAd8ABQGMAAUBngAHAZwAAQGMAAMCBgAaAXkAFwHMABMBagAYAeYAFwFAABMBIAA/AQAAFAH2ABoA3wAgAiMAFACSAHEAvAAXAnIAGQKnABcCRQAYAtYAGQDoABsBIQAaAaAAFQGlABEAkQAhAJUAFgDtABQB2QAjARQAFwEdABsBaAAYAXYAFQFqABcBTQAXAk4AGgCGABQAjgAUAKcAGQDEAB0AqgAVAIEAGwCIABUBSf/VAUn/1QFJ/9UBSf/VAUn/1QFJ/9UA+f/TAPP/0wDz/9MA8//TAPP/0wCJ/9AAif/QAIn/0ACJ/9ABSf/XAQH/3wEB/98BAf/fAQH/3wEB/98BAf/fATL/2gEy/9oBMv/aATL/2gEp/4YBKf+GAaz/1QODAAkDgwAJA4MACQODAAkDgwAJA4MACQTeAAkCgQAVAkEAEgJBABICQQASAkEAEgFwAB0BcAAdAXAAHQFwAB0D+QAVA40AFwLuACAC7gAgAu4AIALuACAC7gAgAu4AIAOYABsDmAAbA5gAGwOYABsDawAbAPsAIQIp//wBswAhAKMAEwEe/ycBVP8nAnAAKgC//9UDoAAfAQb/BAMdABUEMwAgAMX/tQHJ/98DawAbARQAFwHZACMAkABxASEAPwEkAD8DgwAJA2b/+AKBABUAAAC3AQEBAUwBTAFEAUQzN0RMNzs7NwFMAQEBAQEiREwBNyYvAQEBAQEvATcBAQEBAQEhOwEBTBxMAUxEAQEBAUw7REwBAUwBAQEBTAEBASIvL0wBAQFERDc7OwEBAURMM0QBAUQ7AQEiAQEBAQEBAQEBAQEBAQFEAQEBAQEBAQEBAQEBAUwBAQEBAQEzAQEBAQEBAQEBHAEBAQEBAQEBAQEBAQFMOwEBAQEBAQEBAQEBAQEBAQEBTDMvAAAAAAEAAQEBAQEADAD4CP8ACAAI//wACQAJ//wACgAK//wACwAL//sADAAM//sADQAN//oADgAO//oADwAP//oAEAAQ//kAEQAQ//kAEgAR//gAEwAS//gAFAAT//gAFQAU//cAFgAV//cAFwAW//YAGAAX//YAGQAY//YAGgAZ//UAGwAa//UAHAAb//UAHQAc//QAHgAd//QAHwAe//MAIAAf//MAIQAg//MAIgAg//IAIwAh//IAJAAi//EAJQAj//EAJgAk//EAJwAl//AAKAAm//AAKQAn/+8AKgAo/+8AKwAp/+8ALAAq/+4ALQAr/+4ALgAs/+0ALwAt/+0AMAAu/+0AMQAv/+wAMgAv/+wAMwAw/+wANAAx/+sANQAy/+sANgAz/+oANwA0/+oAOAA1/+oAOQA2/+kAOgA3/+kAOwA4/+gAPAA5/+gAPQA6/+gAPgA7/+cAPwA8/+cAQAA9/+YAQQA+/+YAQgA//+YAQwA//+UARABA/+UARQBB/+QARgBC/+QARwBD/+QASABE/+MASQBF/+MASgBG/+IASwBH/+IATABI/+IATQBJ/+EATgBK/+EATwBL/+EAUABM/+AAUQBN/+AAUgBO/98AUwBP/98AVABP/98AVQBQ/94AVgBR/94AVwBS/90AWABT/90AWQBU/90AWgBV/9wAWwBW/9wAXABX/9sAXQBY/9sAXgBZ/9sAXwBa/9oAYABb/9oAYQBc/9kAYgBd/9kAYwBe/9kAZABe/9gAZQBf/9gAZgBg/9gAZwBh/9cAaABi/9cAaQBj/9YAagBk/9YAawBl/9YAbABm/9UAbQBn/9UAbgBo/9QAbwBp/9QAcABq/9QAcQBr/9MAcgBs/9MAcwBt/9IAdABu/9IAdQBu/9IAdgBv/9EAdwBw/9EAeABx/9AAeQBy/9AAegBz/9AAewB0/88AfAB1/88AfQB2/88AfgB3/84AfwB4/84AgAB5/80AgQB6/80AggB7/80AgwB8/8wAhAB9/8wAhQB+/8sAhgB+/8sAhwB//8sAiACA/8oAiQCB/8oAigCC/8kAiwCD/8kAjACE/8kAjQCF/8gAjgCG/8gAjwCH/8cAkACI/8cAkQCJ/8cAkgCK/8YAkwCL/8YAlACM/8UAlQCN/8UAlgCN/8UAlwCO/8QAmACP/8QAmQCQ/8QAmgCR/8MAmwCS/8MAnACT/8IAnQCU/8IAngCV/8IAnwCW/8EAoACX/8EAoQCY/8AAogCZ/8AAowCa/8AApACb/78ApQCc/78ApgCd/74ApwCd/74AqACe/74AqQCf/70AqgCg/70AqwCh/7wArACi/7wArQCj/7wArgCk/7sArwCl/7sAsACm/7sAsQCn/7oAsgCo/7oAswCp/7kAtACq/7kAtQCr/7kAtgCs/7gAtwCt/7gAuACt/7cAuQCu/7cAugCv/7cAuwCw/7YAvACx/7YAvQCy/7UAvgCz/7UAvwC0/7UAwAC1/7QAwQC2/7QAwgC3/7MAwwC4/7MAxAC5/7MAxQC6/7IAxgC7/7IAxwC8/7EAyAC8/7EAyQC9/7EAygC+/7AAywC//7AAzADA/7AAzQDB/68AzgDC/68AzwDD/64A0ADE/64A0QDF/64A0gDG/60A0wDH/60A1ADI/6wA1QDJ/6wA1gDK/6wA1wDL/6sA2ADM/6sA2QDM/6oA2gDN/6oA2wDO/6oA3ADP/6kA3QDQ/6kA3gDR/6gA3wDS/6gA4ADT/6gA4QDU/6cA4gDV/6cA4wDW/6cA5ADX/6YA5QDY/6YA5gDZ/6UA5wDa/6UA6ADb/6UA6QDc/6QA6gDc/6QA6wDd/6MA7ADe/6MA7QDf/6MA7gDg/6IA7wDh/6IA8ADi/6EA8QDj/6EA8gDk/6EA8wDl/6AA9ADm/6AA9QDn/58A9gDo/58A9wDp/58A+ADq/54A+QDr/54A+gDr/54A+wDs/50A/ADt/50A/QDu/5wA/gDv/5wA/wDw/5wAAAAXAAAAvAkLAgACAgUGCQgDBwcGCggIBwYHBwcIBwoGCAgCBAMDAwIDAwEBAwIEAwMDAwICAQMDBAIDAwoFAgYFBAQEBAUFBgUEAwUDAwIFAwUBAgYHBggCAwQFAgIDBQIDAwUEBAYBAQIDAgECAwMDAwMDAgICAgIBAQEBAwICAgICAgMDAwMDAwUICAgICAgLBgUFBQUDAwMDCggHBwcHBwcICAgICAIGBgEDAwYCCAIHCgIECAIEAQMDCAkGAAAACgwCAAICBgcKCQQICAcLCQkIBwgIBwoICwcJCQMEBAQDAQQDAQEDAgQDAwMDAgICAwMFAwMDCwUCBgYEBQQEBQUGBQUEBgMDAwUDBQECBggGCAIDBAUCAgMGAwMEBQUEBwEBAgMCAQIDAwMDAwMCAgICAgEBAQEDAwMDAwMDAwMDAwMDBQkJCQkJCQwGBgYGBgQEBAQLCQgICAgICAkJCQkJAwcGAgMDBgIJAwgLAgUJAwUBAwMJCgYAAAALDgIAAgIGBwsKBAgJBwwKCQkHCQkICggMCAoKAwQEBAQCBAQCAgQCBQQEAwQCAgIDBAUDAwMMBgIGBgQFBAUGBQcFBQQGBAMDBgMGAgIHCAYJAwMFBQICAwYDAwQFBQUHAQICAwIBAwQEBAQEBAMDAwMDAgICAQQDAwMDAwMDAwMDAwMGCgoKCgoKDgcGBgYGBAQEBAwKCAgICAgICgoKCgoDBwYCAwQHAgoDCQwCBQoDBQIDAwoLBwAAAAwPAgACAgcIDAsFCQoHDQoKCggKCQkLCQ0ICwsDBQQEBAIEBAICBAIFBAQEBAMCAgQEBQMEBA0GAwcHBQYFBQYGBwYGBAYEAwMGAwcCAggJBwoDAwUGAgIEBwMDBAYFBQgCAgMDAgIDBAQEBAQEAwMDAwMCAgIBBAMDAwMDAwQEBAQEBAYLCwsLCwsPCAcHBwcEBAQEDQsJCQkJCQkLCwsLCwMIBgIDBAcCCwMKDQIFCwMGAgMECgwIAAAADRADAAMDBwkMDAUKCwgODAsLCQsKCgwKDgkLDAQFBAUEAgQEAgIEAgUEBAQEAwMCBAQGAwQEDgYDBwcFBgUFBwYIBgYFBwQEAwcEBwICCQoHCwMEBQYDAgQHBAQFBgYFCAICAwMCAgMEBAQEBAQDAwMDAwICAgEEAwMDAwMDBAQEBAQEBgwMDAwMDBAICAgICAUFBQUODAoKCgoKCgwMDAwLAwgGAgQECAIMAwoOAwYLBAYCBAQMDAgAAAAPEwMAAwMJCg4OBgsMChEODAwKDQsLDQwRCg0OBQUFBQQDBQUCAgUDBwUEBQUDAwIFBAYEBAQQBwMICAYHBgYHBwkHBwUHBQQECAQIAgMKCwkMAwQGBwMDBAgEBAUGBgYJAgIDBAMCAwUFBQUFBQQEBAQEAgICAQUEBAQEBAQFBQUFBAQHDQ0NDQ0NEwoJCQkJBgYGBhAOCwsLCwsLDg4ODg0ECQcCBAUJAw4EDBADBw0EBwIEBA4OCgAAABAUAwADAwkLDw8GDA0LEg4NDQsNDAwODBILDg8FBQUGBQIFBQICBQMIBQUFBQMDAwUFBgQFBBEIBAkIBwgGBwgHCQcHBggFBQQIBAkCAwoMCg0EBQcHAwMECAQFBgcHBgoCAgMEAwIDBQUFBQUFBAQEBAQCAgIBBQQEBAQEBAUFBQUFBQgODg4ODg4UCgkJCQkGBgYGEQ8MDAwMDAwPDw8PDgQKBwMFBQoDDwQNEQMHDgQIAgUFDg8KAAAAERUDAAMDCgsQEAcNDgoTDw4ODA4NDRANEwwPEAUGBQYFAwUFAgIGAwgGBQUFBAMDBQUHBAUFEggECQkHCAcHCAcKBwgGCAUFBAkECQIDCwwKDQQFBwcDAwQJBQUGBwcHCgICAgQDAgMGBgYGBgYEBAQEBAICAgEGBAQEBAQEBQUFBQUFCA8PDw8PDxULCgoKCgYGBgYSDw0NDQ0NDRAQEBAPBAoHAwUGCwMQBA4SAwgPBQgCBQUPDwsAAAATGAQABAQLDRESBg4PDBURDxANDw8OEQ8VDRES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BiMiJjU0NicyFhUUByImNTQ2KAwSDAYSCQcIBgQLNiYNCQMHDRMWCBUzGhwnAwMQFRUGBQdTCg8UDQ4QFUYNEBwSEREBcBAXGwwgRiECFBscCQkBWWokEAQELDo9FDNBJyALDg8/SkgXEQmDAg4HDREQCQ4OAwwMHAMQCwwQAAD////X//8BgAH2AiYAJwAAAAYAYVAAAAD////f//8BLgIMAiYAKAAAAAYAXz0AAAD////f//8BLgIIAiYAKAAAAAYAYDoAAAD////f//8BLgIJAiYAKAAAAAYAYywAAAD////f//8BLgH2AiYAKAAAAAYAYSwAAAD////f//8BLgH2AiYAKAAAAAYAYhoAAAD////f/9IBLgFzAiYAKAAAAEYARwgTHREdCAAA////2v//AVsCDAImAC4AAAAGAF9WAAAA////2v//AVsCCAImAC4AAAAGAGBSAAAA////2v//AVsCCQImAC4AAAAGAGNEAAAA////2v//AVsB9gImAC4AAAAGAGIzAAAA////hv6AAVYCCAImADIAAAAGAGBOAAAA////hv6AAVYB9gImADIAAAAGAGIuAAAAAAT/1QAAAd4BdAAxAEIAbgCCAia7ADwABgARAAQruwBIAAYABwAEK7sAaQAHAH4ABCtBFQAGAEgAFgBIACYASAA2AEgARgBIAFYASABmAEgAdgBIAIYASACWAEgACl1BBQClAEgAtQBIAAJdugAJAAcASBESOboAGwAHAEgREjm6ADQABwBIERI5uAA0L7kAJAAG9EEVAAYAPAAWADwAJgA8ADYAPABGADwAVgA8AGYAPAB2ADwAhgA8AJYAPAAKXUEFAKUAPAC1ADwAAl24AEgQuQBhAAb0ugB5ADQAJBESOUEFAKoAfgC6AH4AAl1BFQAJAH4AGQB+ACkAfgA5AH4ASQB+AFkAfgBpAH4AeQB+AIkAfgCZAH4ACl24AGkQuACE3AC4ABYvuAAhL7gAZi+4AABFWLgAAC8buQAAAAk+WbgAAEVYuAACLxu5AAIACT5ZuAAARVi4AA4vG7kADgAJPlm4AABFWLgAXC8buQBcAAk+WboACQAOABYREjm4ACEQuAAX0LgAFy+4ACEQuABu3LoAGwAhAG4REjm4AAAQuQBLAAT0QSEABwBLABcASwAnAEsANwBLAEcASwBXAEsAZwBLAHcA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</textarea><br>
<svg height="1200" width="2000" id="svg" xmlns="http://www.w3.org/2000/svg" style="display:none">

  Sorry, your browser does not support inline SVG.
</svg>

<!---------------- image to gcode                     ----------------------------->

  <div class="row">
  <div class="column" >
  <input  onchange="my();" type="text" placeholder="Write your text here..." name="text" class="input" id="litera"><input type="checkbox" id="nome" checked="" onchange="my();" class="btn1">Name<input type="checkbox" id="contourz" onchange="my();" checked="" class="btn1">Contour<hr>
  <input class="slider" style="width:20%;" type="range" min="100" max="800" step="10" value="300" id="myRanges" onchange="my()" ontouchmove="costycnc1(this.value)"><hr>
  ROTATE TABLE<hr>


             <input class="input" id="rotate" value="8" onchange="display()"> Rotate<hr>
      <input class="input" id="stepr" value="12.8">STEP/ROTATE(Mini 32)<hr><button class="btn" onclick="turn()">TEST</button>
	  
	 
Rotate table-<input type="checkbox" onchange="display()" id="pr" class="cyberpunk-checkbox">

	  
	  
     
dpi:
	  
	      <select id="scaledpi" onchange="display();localStorage.dpi=this.selectedIndex;console.log(this.selectedIndex)" class="btn1">
		  <option value="96">96</option>
          <option value="72">72</option>
          <option value="120">120</option>
          <option value="300">300</option>
          </select>
		  	              <input   style="display:none" class="slider" type="range" min="5" max="20" step=".01" value="19" id="myRanges" onmousemove="scale=20-this.value;svg2.attr('viewBox','0,0,'+(scale)+','+(scale));" ontouchmove="scale=20-this.value;svg2.attr('viewBox','0,0,'+(scale)+','+(scale));">
						  
          
<a href="#" onclick="fetch('/command?commandText=%18'); return false;"
   style="
     display: inline-block;
     padding: 20px 40px;
     background-color: red;
     color: white;
     font-size: 24px;
     font-weight: bold;
     text-align: center;
     border-radius: 10px;
     text-decoration: none;
     box-shadow: 2px 2px 8px rgba(0,0,0,0.3);
     margin: 10px;
   ">
  🛑 STOP MACCHINA
</a>

  </div>
  <div class="column">
           <input id="raport1" value="1" onchange="calculeaza1()" class="btn1">Rap X
      <hr>  <input id="raport2" value="1" onchange="calculeaza1()" disabled="" class="btn1">Rap Y
      <hr><input type="text" id="calcx" onchange="calculeaza()" class="btn1">Dim X(CM)
	  <hr><input type="text" id="calcy" onchange="calculeaza()" disabled="" class="btn1">Dim Y(CM)
      <hr><input type="checkbox" id="due" onchange="check();" checked="" class="btn1">RAP (make Y editable)<hr>
	  <input type="text" id="feedrate" value="500" onchange="localStorage.feedrate=this.value;" class="btn1">Feedrate F<hr>
	  <input type="text" id="hotwire" value="1000" onchange="localStorage.hotwire=this.value;" class="btn1">Hotwire S(maxim 1000)

  </div>
  <div class="column" >
      GCODE:<hr><textarea cols="22" form="usrform1" id="gcode" name="textg" rows="6" onchange="costycncdesign(this.value)" class="btn1"></textarea>
	   <iframe width="50%" height="25%" src="https://www.youtube.com/embed/TKJvfNVCVSg?si=lzJ8e0SRDwIPkT8u" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<hr>
	  <button onclick="xhr();" class="btn">EXECUTE costycnc.nc</button><button onclick="savegcodetomks1();" class="btn">Scrive on SDCARD</button><hr>     
	  <input type="file" id="flvalue" accept=".bmp,.jpg,.png,.svg" onchange="openFile(event)" class="btn"><hr>
	  
	  <a href="/index.html"><button class="btn">HOME PAGE</button><button onclick="saveTextAsFile()" class="btn">Save gcode</button></a>
	  <hr>name file<input type="text" id="nfile" value="costycnc">.nc
	  <a href="/command?commandText=%5BESP221%5D/costycnc.nc&PAGEID=0"><button class="btn">VIEW costycnc.nc</button></a><hr>
	  <input type="checkbox" id="contour" onchange="contoura();" class="btn1">only contour
  </div>
</div>
        
           
    <div >
    <svg id="svgcode" xmlns="http://www.w3.org/2000/svg" width="3000mm" height="1500mm" viewBox="0 0 3000 1500" style="background-color:black">
    </svg>
    </div>



<script>
var svg1=document.getElementById("svg");
var svg2=document.getElementById("svgcode");
var nome=document.getElementById("nome");
var contourz=document.getElementById("contourz");

function my(){





var fonth=document.getElementById("myRanges").value;
var value=document.getElementById("litera").value;
var font=document.getElementById("textarea").value;
var propr ="@font-face {";
propr +="font-family: 'Roboto';";
propr +="font-style: normal;";
propr +="font-weight: 400;";
propr +="src: url(";
propr +=font;
propr +=") format('woff');}" ;
svg1.innerHTML="";	


var st = document.createElementNS("http://www.w3.org/2000/svg", 'style'); //Create a path in SVG's namespace 
st.innerHTML = propr;
svg1.appendChild(st);

var txt = document.createElementNS("http://www.w3.org/2000/svg", 'text'); //Create a path in SVG's namespace 
txt.innerHTML = value;
txt.setAttribute("font-size",fonth);
txt.setAttribute("x",50);
txt.setAttribute("y",fonth);

if (nome.checked && contourz.checked) {
    txt.setAttribute("fill","white");
    txt.setAttribute("stroke","black");
} else {
    if(nome.checked){
    txt.setAttribute("fill","black");
    txt.setAttribute("stroke","white");}
	else{
	
    txt.setAttribute("fill","black");
    txt.setAttribute("stroke","black");}

}


txt.setAttribute("stroke-width","40px");
txt.setAttribute("font-family","Roboto");
txt.setAttribute("paint-order","stroke");
svg1.appendChild(txt);
var s = new XMLSerializer().serializeToString(svg1);
var encodedData = "data:image/svg+xml;base64,"+window.btoa(s);
myFunction(encodedData);

}



</script>

<!----------------------------------------   mks save file                         ---------------------------->
<script>

if (localStorage.hotwire){
document.getElementById("hotwire").value=localStorage.hotwire;
}

if (localStorage.feedrate){
document.getElementById("feedrate").value=localStorage.feedrate;
}


if (localStorage.dpi){
console.log(localStorage.dpi);
document.getElementById("scaledpi").selectedIndex=localStorage.dpi;
}

function xhr(){
console.log("xhr()");
const xhr = new XMLHttpRequest();
xhr.open("POST", "/command?commandText=%5BESP220%5D/costycnc.nc&PAGEID=0");

xhr.onload = function() {
  if (xhr.status === 200) {
    // Upload successful
    console.log('File uploaded successfully');
  } else {
    // Upload failed
    console.error('Error uploading file');
    showErrorDialog('Error uploading file. Please check your SD card and try again.');
  }
};

xhr.onerror = function() {
  // Network error
  console.error('Network error');
  showErrorDialog('A network error occurred. Please check your internet connection and try again.');
};


xhr.send();
}

function costycncmks(){

console.log("costycncmks()");
var file = document.getElementById("files_input_file").files;
document.getElementById("name-file").href="/command?commandText=%5BESP220%5D/"+file[0].name+"&PAGEID=0"
document.getElementById("name-file").innerHTML=file[0].name;

var formData = new FormData();
formData.append("path", "/");
i = "/" + file[0].name + "S";
formData.append(i, file[0].size);
formData.append("myfile[]", file[0], "/" + file[0].name);
document.getElementById("files_input_file").value = "";


var xhr = new XMLHttpRequest();
xhr.open('POST', '/upload', true);


xhr.onload = function() {
  if (xhr.status === 200) {
    // Upload successful
    console.log('File uploaded successfully');
  } else {
    // Upload failed
    console.error('Error uploading file');
    showErrorDialog('Error uploading file. Please check your SD card and try again.');
  }
};

xhr.onerror = function() {
  // Network error
  console.error('Network error');
  showErrorDialog('A network error occurred. Please check your internet connection and try again.');
};


xhr.send(formData);
}

//function savegcodetomks(val){


function savegcodetomks1(){
console.log("savegcodetomks(val)");

var valgcode=document.getElementById("gcode").value;

var valname=document.getElementById("nfile").value+".nc";


var parts = [
  new Blob(['you construct a file...'], {type: 'text/plain'}),
  ' Same way as you do with blob',
  new Uint16Array([33])
];

var parts1 = [
new Blob([valgcode], {type: 'text/plain'})
];


// Construct a file
var file = new File(parts1, valname, {
    lastModified: new Date(0), // optional - default = now
    type: "overide/mimetype" // optional - default = ''
});




var formData = new FormData();
formData.append("path", "/");
i = "/" + file.name + "S";
formData.append(i, file.size);
formData.append("myfile[]", file, "/" + file.name);
//document.getElementById("files_input_file").value = "";


var xhr = new XMLHttpRequest();
xhr.open('POST', '/upload', true);

xhr.onload = function() {
  if (xhr.status === 200) {
    // Upload successful
    console.log('File uploaded successfully');
  } else {
    // Upload failed
    console.error('Error uploading file');
    showErrorDialog('Error uploading file. Please check your SD card and try again.');
  }
};

xhr.onerror = function() {
  // Network error
  console.error('Network error');
  showErrorDialog('A network error occurred. Please check your internet connection and try again.');
};

xhr.send(formData);


function showErrorDialog(message) {
  // Create the error dialog
  var dialog = document.createElement('div');
  dialog.id = 'error-dialog';
  dialog.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    border: 1px solid black;
    padding: 20px;
    z-index: 1000;
	color:black;
  `;

  // Add the error message to the dialog
  var messageElement = document.createElement('p');
  var messageTextNode = document.createTextNode(message);
messageElement.appendChild(messageTextNode);
 dialog.appendChild(messageElement);

  // Add a close button to the dialog
  var closeButton = document.createElement('button');
  closeButton.textContent = "OK";
  closeButton.onclick = function() {
    document.body.removeChild(dialog);
  };
  dialog.appendChild(closeButton);

  // Add the dialog to the page
  document.body.appendChild(dialog);
}




}

</script>

<!-------------------- part1.js ---------------------------->

<script>
var contourx=0;



      function costycncdesign(gcode) {
        val3 = 0;
        val4 = 0;
		svg2.innerHTML="";
        var myArr = gcode.split("\n");
        for (let i = 0; i < myArr.length; i++) {
          val1 = myArr[i].split(" ");
          if (val1[0] == "G01") {
            if (val1[1]) {
              val5 = val1[1].substring(1);
            } else {
              val5 = val3;
            }
            if (val1[2]) {
              val6 = val1[2].substring(1)
            } else {
              val6 = val4
            }

			
			var line = document.createElementNS("http://www.w3.org/2000/svg", 'line'); //Create a path in SVG's namespace 
			line.setAttribute("x1",val3);
			line.setAttribute("y1",val4);
			line.setAttribute("x2",val5);
			line.setAttribute("y2",val6);
			line.setAttribute("stroke","white");
			line.setAttribute("stroke-width",1);
			svg2.appendChild(line);

			
            val3 = val5;
            val4 = val6;
          }
        }
       }
	   

</script>

<!----------------------------- part2.js                      ------------------------------------->


<script>
   /*
			25.09.2021 adaugat daca text/plain base64 send direct to base64  >> ramane sa testez daca text contine base64 o no
			*/
      var initialx = 0;
      var dataURL;
      var initialy = 0;
      var rapx = 1;
      var rapy = 1;
      var scaledpi = 96;
      var gcode_value = "";
	  
	          // Evita il comportamento predefinito per gli eventi di drag
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            window.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
       
        
window.addEventListener('drop', function(e) {
    const dt = e.dataTransfer;
    const files = dt.files;
    if (files.length > 0) { // Verifica che ci siano file
        const file = files[0]; // Ottieni l'oggetto File
        if (file.type.match('^image/')) {
            const reader = new FileReader();
            reader.onload = (e) => myFunction(e.target.result);
            reader.readAsDataURL(file); // Passa l'oggetto File corretto
        }
    }
});	
	  
	  
      //inspired from 
      //https://ourcodeworld.com/articles/read/491/how-to-retrieve-images-from-the-clipboard-with-javascript-in-the-browser	
      function retrieveImageFromClipboardAsBlob(pasteEvent, callback) {
        if (pasteEvent.clipboardData == false) {
          if (typeof(callback) == "function") {
            callback(undefined);
          }
        };
        var items = pasteEvent.clipboardData.items;
        if (items == undefined) {
          if (typeof(callback) == "function") {
            callback(undefined);
          }
        };
        for (var i = 0; i < items.length; i++) {
          console.log("type=" + items[i].type);
          // Skip content if not image
          if (items[i].type.indexOf("image") == -1) continue;
          // Retrieve image on clipboard as blob
          var blob = items[i].getAsFile();
          if (typeof(callback) == "function") {
            callback(blob);
          }
        }
      }
      window.addEventListener("paste", function(e) {
        //25.09.2021 1
		console.log("event");
        var items = e.clipboardData.items;
        var file = items[0].type;
        if (file == "text/plain") {
          console.log("este text plain");
          const dT = e.clipboardData;
          const html = dT.getData('text/plain');
          myFunction(html);
        } else {
          // Handle the event
          retrieveImageFromClipboardAsBlob(e, function(imageBlob) {
            // If there's an image, display it in the canvas
            console.log(imageBlob);
            if (imageBlob) {
              console.log("imageblob=" + imageBlob);
              var reader = new FileReader();
              reader.onload = function() {
                dataURL = reader.result;
                //console.log("dataURL="+dataURL);
              };
              reader.readAsDataURL(imageBlob);
              setTimeout(function() {
                myFunction(dataURL);
              }, 500);
            }
          });
        }
      });
      ///////////	
      var openFile = function(event) {
        var input = event.target;
        var reader = new FileReader();
        reader.onload = function() {
          dataURL = reader.result;
        };
        reader.readAsDataURL(input.files[0]);
		
        setTimeout(function() {
          myFunction(dataURL);
        }, 500);
      }
      function myFunction(dataurl) {
        Potrace.loadImageFromUrl(dataurl,contourx);//23/11/2022 contourx
        Potrace.process(function() {
          display(); //solo prima volta	
          initialx = Potrace.getdimx();
          initialy = Potrace.getdimy();
        });
      }
      function display() {
        //questa funzie ogni volta quando cambia valore
        scaledpi = document.getElementById('scaledpi').value;
        var rotate = document.getElementById('rotate').value;
        var stepr = document.getElementById('stepr').value;
		var rot=stepr/rotate
        //var svgdiv = document.getElementById('svgdiv');
        //svgdiv.style.display = 'inline-block';
        //svgdiv.innerHTML = "< p > Result: < /p>" + Potrace.getSVG(rapx /5, rapy / 5);
      //var gcode = document.getElementById('gcode');
      var var_tmpx = 2.54 * rapx * 10;
      var var_tmpy = 2.54 * rapy * 10;
      gcode_value = "";
      var gcodegcode = Potrace.getSVG1(var_tmpx / scaledpi, var_tmpy / scaledpi);
      //(scaledpi/2.54)*rapx,(scaledpi/2.54)*rapy
      //var gcodegcode = Potrace.getSVG1(var_tmpx/scaledpi,var_tmpy/scaledpi);
      if (document.getElementById("pr").checked) {
        for (let i = 0; i < rotate; i++) {
          var strd = "G01 Z"+rot+"\nG92 Z0\n";
          gcode_value += gcodegcode;
          gcode_value += strd;
        }
        document.getElementById('gcode').value = gcode_value;
		//savegcodetomks(gcode_value);
	
      } else {
        gcode_value = gcodegcode;
        document.getElementById('gcode').value = gcode_value;
        costycncdesign(gcode_value);
		//savegcodetomks(gcode_value);
		
      }
      //scrie calcx cu dimx in mm lo deve dividere cu 10 per cm
      document.getElementById("calcx").value = (Potrace.getdimx() / 10).toFixed(1);
      document.getElementById("calcy").value = (Potrace.getdimy() / 10).toFixed(1);
      }
	     function contoura() {//23/11/2022 add function contoura
		 
	    document.getElementById('flvalue').value = '';//23/11/2022 clear cache file per poter caricare stessa file
		if (document.getElementById("contour").checked) {
			contourx=1;
        } else {
            contourx=0;
        }
		}
      function check() {
        if (document.getElementById("due").checked) {
          document.getElementById("calcy").disabled = true;
          document.getElementById("raport2").disabled = true;
        } else {
          document.getElementById("calcy").disabled = false;
          document.getElementById("raport2").disabled = false;
        }
        calculeaza();
      }
      function calculeaza1() {
        rapx = document.getElementById("raport1").value;
        rapy = document.getElementById("raport2").value;
        if (document.getElementById("due").checked) rapy = rapx;
        document.getElementById("raport2").value = rapy;
        display();
      }
      function calculeaza() {
        //citeste calcx che in cm ... risposta deve esssere in mm cioe *10
        var valo = document.getElementById("calcx").value * 10;
        rapx = valo / initialx;
        console.log("rap=" + rapx);
        var valo = document.getElementById("calcy").value * 10;
        rapy = valo / initialy;
        if (document.getElementById("due").checked) rapy = rapx;
        document.getElementById("raport1").value = rapx;
        document.getElementById("raport2").value = rapy;
        display();
      }
      function saveTextAsFile() {
        //var gcode = document.getElementById('gcode').value;
        gcode_value = document.getElementById('gcode').value;
        var textToSaveAsBlob = new Blob([gcode_value], {
          type: "text/plain"
        });
        var textToSaveAsURL = window.URL.createObjectURL(textToSaveAsBlob);
        var fileNameToSaveAs = "costycnc.nc";
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        downloadLink.href = textToSaveAsURL;
        downloadLink.onclick = destroyClickedElement;
        downloadLink.style.display = "none";
        document.body.appendChild(downloadLink);
        downloadLink.click();
      }
      function destroyClickedElement(event) {
        document.body.removeChild(event.target);
      }

</script>

<!------- potrace.2.js---------------------------------->

<script>
/* 
 * A javascript port of Potrace (http://potrace.sourceforge.net).
 * 
 * Licensed under the GPL
 * 
 * Usage
 *   loadImageFromFile(file) : load image from File API
 *   loadImageFromUrl(url): load image from URL
 *     because of the same-origin policy, can not load image from another domain.
 *     input color/grayscale image is simply converted to binary image. no pre-
 *     process is performed.
 * 
 *   setParameter({para1: value, ...}) : set parameters
 *     parameters:
 *        turnpolicy ("black" / "white" / "left" / "right" / "minority" / "majority")
 *          how to resolve ambiguities in path decomposition. (default: "minority")       
 *        turdsize
 *          suppress speckles of up to this size (default: 2)
 *        optcurve (true / false)
 *          turn on/off curve optimization (default: true)
 *        alphamax
 *          corner threshold parameter (default: 1)
 *        opttolerance 
 *          curve optimization tolerance (default: 0.2)
 *       
 *   process(callback) : wait for the image be loaded, then run potrace algorithm,
 *                       then call callback function.
 * 
 *   getSVG: getSVG(size, opt_type) : return a string of generated SVG image.
 *                                    result_image_size = original_image_size * size
 *                                    optional parameter opt_type can be "curve"
 */
 //########################################################################################################
 var contour=0;
var tmp_point=[];
var tmp_path=[];
var path_final;
var path_len_temp=0;
//##################################################################################################################
  var dim_x=0,filex="";
var dim_y=0;  
var dim_tempx=0;
var dim_tempy=0;
var maxx=0;
var maxy=0;
var minx=0;
var miny=0;
var xx=0;
var yy=0;
var minx0=100000;
var miny0=100000;
var maxx0=0;
var maxy0=0;
var path_area=0,path_len=0,path_maxX=0,path_maxY=0,path_minX=100000,path_minY=100000,path_pt=[];
//########################################################################################################
var Potrace = (function() {
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }
  Point.prototype.copy = function(){
    return new Point(this.x, this.y);
  };
  function Bitmap(w, h) {
    this.w = w;
    this.h = h;
    this.size = w * h;
    this.arraybuffer = new ArrayBuffer(this.size);
    this.data = new Int8Array(this.arraybuffer);
  }
  Bitmap.prototype.at = function (x, y) {
    return (x >= 0 && x < this.w && y >=0 && y < this.h) && 
        this.data[this.w * y + x] === 1;
  };
  Bitmap.prototype.index = function(i) {
    var point = new Point();
    point.y = Math.floor(i / this.w);
    point.x = i - point.y * this.w;
    return point;
  };
  Bitmap.prototype.flip = function(x, y) {
    if (this.at(x, y)) {
      this.data[this.w * y + x] = 0;
    } else {
      this.data[this.w * y + x] = 1;
    }
  };
  Bitmap.prototype.copy = function() {
    var bm = new Bitmap(this.w, this.h), i;
    for (i = 0; i < this.size; i++) {
      bm.data[i] = this.data[i];
    }
    return bm;
  };
  function Path() {
    this.area = 0;
    this.len = 0;
    this.curve = {};
    this.pt = [];
    this.minX = 100000;
    this.minY = 100000;
    this.maxX= -1;
    this.maxY = -1;
  }
  function Curve(n) {
    this.n = n;
    this.tag = new Array(n);
    this.c = new Array(n * 3);
    this.alphaCurve = 0;
    this.vertex = new Array(n);
    this.alpha = new Array(n);
    this.alpha0 = new Array(n);
    this.beta = new Array(n);
  }
  var imgElement = document.createElement("img"),
      imgCanvas = document.createElement("canvas"),
      bm = null,
      pathlist = [],
      callback,
      info = {
        isReady: false,
        turnpolicy: "minority", 
        turdsize: 50,
        optcurve: false,
        alphamax: 1,
        opttolerance: 0.2
      };
  imgElement.onload = function() {
	  console.log("onload");
    loadCanvas();
    loadBm();
  };
  function loadImageFromFile(file) {
      filex="file";
//#############################reset tutte le variabile###########################################################################
tmp_point=[];tmp_path=[];path_final;path_len_temp=0;
//##################################################################################################################
dim_x=0;dim_y=0;dim_tempx=0;dim_tempy=0;maxx=0;maxy=0;xx=0;yy=0;maxx0=0;maxy0=0;minx=0;miny=0;minx0=100000;miny0=100000;
path_area=0;path_len=0;path_maxX=0;path_maxY=0;path_minX=100000;path_minY=100000;path_pt=[];
//#####################################################################################################
    if (info.isReady) {
      clear();
    }
    imgElement.file = file;
    var reader = new FileReader();
    reader.onload = (function(aImg) {
      return function(e) {
        aImg.src = e.target.result;
      };
    })(imgElement);
    reader.readAsDataURL(file);
  }
  function loadImageFromUrl(url,contourx) {
      contour=contourx;
	  filex="url";
    if (info.isReady) {	
      clear();
    }
    imgElement.src = url;
  }
  function setParameter(obj) {
   var key;
   for (key in obj) {
     if (obj.hasOwnProperty(key)) {
       info[key] = obj[key];
     }
    }
  }
  function loadCanvas() {
    imgCanvas.width = imgElement.width;
    imgCanvas.height = imgElement.height;
    var ctx = imgCanvas.getContext('2d');
    ctx.drawImage(imgElement, 0, 0);
  }
  function loadBm() {
    var ctx = imgCanvas.getContext('2d');
    //eliminate transparency
    	var imgData=ctx.getImageData(0,0,imgCanvas.width,imgCanvas.height);
var data=imgData.data;
for(var i=0;i<data.length;i+=4){
    if(data[i+3]<255){
        data[i]=255;
        data[i+1]=255;
        data[i+2]=255;
        data[i+3]=255;
    }
}
ctx.putImageData(imgData,0,0);
    //end routine eliminate transparency
    bm = new Bitmap(imgCanvas.width, imgCanvas.height);
    var imgdataobj = ctx.getImageData(0, 0, bm.w, bm.h);
    var l = imgdataobj.data.length, i, j, color;
    for (i = 0, j = 0; i < l; i += 4, j++) {
//alert(imgdataobj.data[i + 3]);
      color = 0.2126 * imgdataobj.data[i] + 0.7153 * imgdataobj.data[i + 1] +
          0.0721 * imgdataobj.data[i + 2];
      bm.data[j] = (color < 128 ? 1 : 0);
    }
    info.isReady = true;
  }
  
  function bmToPathlist() {
    var bm1 = bm.copy(),
      currentPoint = new Point(0, 0),
      path;
    function findNext(point) {
      var i = bm1.w * point.y + point.x;
      while (i < bm1.size && bm1.data[i] !== 1) {
        i++;
      }
      return i < bm1.size && bm1.index(i);
    }
    function majority(x, y) {
      var i, a, ct;
      for (i = 2; i < 5; i++) {
        ct = 0;
        for (a = -i + 1; a <= i - 1; a++) {
          ct += bm1.at(x + a, y + i - 1) ? 1 : -1;
          ct += bm1.at(x + i - 1, y + a - 1) ? 1 : -1;
          ct += bm1.at(x + a - 1, y - i) ? 1 : -1;
          ct += bm1.at(x - i, y + a) ? 1 : -1;
        }
        if (ct > 0) {
          return 1;
        } else if (ct < 0) {
          return 0;
        }
      }
      return 0;
    }
    function findPath(point) {
      var path = new Path(),
        x = point.x, y = point.y,
        dirx = 0, diry = 1, tmp;
      path.sign = bm.at(point.x, point.y) ? "+" : "-";
      while (1) {
        path.pt.push(new Point(x, y));
        path_pt.push(new Point(x, y));
        if (x > path.maxX)
          path.maxX = x;
        if (x < path.minX)
          path.minX = x;
        if (y > path.maxY)
          path.maxY = y;
        if (y < path.minY)
          path.minY = y;
        if (x > path_maxX)
          path_maxX = x;
        if (x < path_minX)
          path_minX = x;
        if (y > path_maxY)
          path_maxY = y;
        if (y < path_minY)
          path_minY = y;
        path.len++;
        path_len++;
        x += dirx;
        y += diry;
        path.area -= x * diry;
        path_area -= x * diry;
        if (x === point.x && y === point.y)
          break;
        var l = bm1.at(x + (dirx + diry - 1 ) / 2, y + (diry - dirx - 1) / 2);
        var r = bm1.at(x + (dirx - diry - 1) / 2, y + (diry + dirx - 1) / 2);
        if (r && !l) {
          if (info.turnpolicy === "right" ||
          (info.turnpolicy === "black" && path.sign === '+') ||
          (info.turnpolicy === "white" && path.sign === '-') ||
          (info.turnpolicy === "majority" && majority(x, y)) ||
          (info.turnpolicy === "minority" && !majority(x, y))) {
            tmp = dirx;
            dirx = -diry;
            diry = tmp;
          } else {
            tmp = dirx;
            dirx = diry;
            diry = -tmp;
          }
        } else if (r) {
          tmp = dirx;
          dirx = -diry;
          diry = tmp;
        } else if (!l) {
          tmp = dirx;
          dirx = diry;
          diry = -tmp;
        }
      }
      return path;
    }
    function xorPath(path){
      var y1 = path.pt[0].y,
        len = path.len,
        x, y, maxX, minY, i, j;
      for (i = 1; i < len; i++) {
        x = path.pt[i].x;
        y = path.pt[i].y;
        if (y !== y1) {
          minY = y1 < y ? y1 : y;
          maxX = path.maxX;
          for (j = x; j < maxX; j++) {
            bm1.flip(j, minY);
          }
          y1 = y;
        }
      }
    }
    while (currentPoint = findNext(currentPoint)) {
      path = findPath(currentPoint);
      xorPath(path);
      if (path.area > info.turdsize) {
        pathlist.push(path);
//####################################################################################################################################
      for (var i = 0; i < path.pt.length; i++) {
           tmp_point.push([path.pt[i].x,path.pt[i].y]);
    }
	//console.log(path);
	tmp_path.push(tmp_point);
	tmp_point=[];
//######################################################################################################################################
      }
    }
	if(!contour){
	path_final=extract(tmp_path);
	//console.log(pathlist);
	p=path_final.splice(-1,1);
}else{
		path_final=tmp_path[0];
}
	//console.log("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");
	//console.log(path_final);
	//to point
/*
    console.log("path.area--> "+pathlist[0].area+"+"+pathlist[1].area+"="+path_area);
    console.log("path.len--> "+pathlist[0].len+"+"+pathlist[1].len+"="+path_len);
    console.log("path.maxX--> "+pathlist[0].maxX+","+pathlist[1].maxX+"="+path_maxX);
    console.log("path.maxY--> "+pathlist[0].maxY+","+pathlist[1].maxY+"="+path_maxY);
    console.log("path.minX--> "+pathlist[0].minX+","+pathlist[1].minX+"="+path_minX);
    console.log("path.minY--> "+pathlist[0].minY+","+pathlist[1].minY+"="+path_minY);
    console.log("path[0].pt--> "+pathlist[0].pt.length+","+pathlist[1].pt.length+"="+path_pt.length);
	console.log("path_final[0]");
	console.log(path_final[0]);
	*/
	pathlist=[];
	pathlist.push(new Path());
	loc_minX = 100000;
    loc_minY = 100000;
    loc_maxX= -1;
    loc_maxY = -1;
    path_len_temp = 0;
	path_len = 0;
	      for (var i = 0; i < path_final.length; i++) {
			  x=path_final[i][0];
			  y=path_final[i][1];
			  pathlist[0].pt.push(new Point(x, y));
			  path_len_temp++;
		if (x > loc_maxX)
          loc_maxX = x;
        if (x < loc_minX)
          loc_minX = x;
        if (y > loc_maxY)
          loc_maxY = y;
        if (y < loc_minY)
          loc_minY = y;
    }
	console.log("path_len_temp="+path_len_temp+" path_len="+path_len);
	//dim_x=((loc_maxX-loc_minX)*2.54/96);
	//dim_y=((loc_maxY-loc_minY)*2.54/96);
	dim_tempx=loc_maxX-loc_minX;
	dim_tempy=loc_maxY-loc_minY;
	/*
    console.log(loc_maxX);
    console.log(loc_maxY);
    console.log(loc_minX);
    console.log(loc_minY);
    console.log(path_maxX);
    console.log(path_maxY);
    console.log(path_minX);
    console.log(path_minY);
 */
	pathlist[0].area=path_area;
	pathlist[0].len=path_len_temp;
	pathlist[0].maxX=path_maxX;
	pathlist[0].maxY=path_maxY;
	pathlist[0].minX=path_minX;
	pathlist[0].minY=path_minY;
	//pathlist[0].pt=path_pt;
	pathlist[0].sign="+";
		//console.log("pathlist[0].pt[0] 372");
	//console.log(pathlist[0].pt[0])
/*
pathlist_temp=[];
pathlist_point=[];
console.log("pathlist.length");
console.log(pathlist.length);
console.log("pathlist[0].pt.length");
console.log(pathlist[1].pt.length);
			for(let m =0; m< pathlist.length; m++){
				for(let n =0; n< pathlist[m].pt.length; n++){
				pathlist_point.push([pathlist[m].pt[n].x,pathlist[m].pt[n].y]);
				      } 
				pathlist_temp.push(pathlist_point);	
				pathlist_point=[];
					  }
extract(pathlist_temp);
	console.log(pathlist);
    console.log("path.area--> "+pathlist[0].area+"+"+pathlist[1].area+"="+path_area);
    console.log("path.len--> "+pathlist[0].len+"+"+pathlist[1].len+"="+path_len);
    console.log("path.maxX--> "+pathlist[0].maxX+","+pathlist[1].maxX+"="+path_maxX);
    console.log("path.maxY--> "+pathlist[0].maxY+","+pathlist[1].maxY+"="+path_maxY);
    console.log("path.minX--> "+pathlist[0].minX+","+pathlist[1].minX+"="+path_minX);
    console.log("path.minY--> "+pathlist[0].minY+","+pathlist[1].minY+"="+path_minY);
    console.log("path[0].pt--> "+pathlist[0].pt.length+","+pathlist[1].pt.length+"="+path_pt.length);
	costy_extract=extract(pathlist[0].pt);
	console.log(costy_extract);
	pathlist=[];
	pathlist.push(new Path());
	pathlist[0].area=path_area;
	pathlist[0].len=path_len;
	pathlist[0].maxX=path_maxX;
	pathlist[0].maxY=path_maxY;
	pathlist[0].minX=path_minX;
	pathlist[0].minY=path_minY;
	pathlist[0].pt=path_pt;
	pathlist[0].sign="-";
	console.log(pathlist)
*/
  }
  //################################################################################################################
  function processPath() {
    function Quad() {
      this.data = [0,0,0,0,0,0,0,0,0];
    }
    Quad.prototype.at = function(x, y) {
      return this.data[x * 3 + y];
    };
    function Sum(x, y, xy, x2, y2) {
      this.x = x;
      this.y = y;
      this.xy = xy;
      this.x2 = x2;
      this.y2 = y2;
    }
    function mod(a, n) {
        return a >= n ? a % n : a>=0 ? a : n-1-(-1-a) % n;
    }
    function xprod(p1, p2) {
      return p1.x * p2.y - p1.y * p2.x;
    }
    function cyclic(a, b, c) {
      if (a <= c) {
        return (a <= b && b < c);
      } else {
        return (a <= b || b < c);
      }
    }
    function sign(i) {
      return i > 0 ? 1 : i < 0 ? -1 : 0;
    }
    function quadform(Q, w) {
      var v = new Array(3), i, j, sum;
      v[0] = w.x;
      v[1] = w.y;
      v[2] = 1;
      sum = 0.0;
      for (i=0; i<3; i++) {
        for (j=0; j<3; j++) {
          sum += v[i] * Q.at(i, j) * v[j];
        }
      }
      return sum;
    }
    function interval(lambda, a, b) {
      var res = new Point();
      res.x = a.x + lambda * (b.x - a.x);
      res.y = a.y + lambda * (b.y - a.y);
      return res;
    }
    function dorth_infty(p0, p2) {
      var r = new Point();
      r.y = sign(p2.x - p0.x);
      r.x = -sign(p2.y - p0.y);
      return r;
    }
    function ddenom(p0, p2) {
      var r = dorth_infty(p0, p2);
      return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
    }
    function dpara(p0, p1, p2) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
      return x1 * y2 - x2 * y1;
    }
    function cprod(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
      return x1 * y2 - x2 * y1;
    }
    function iprod(p0, p1, p2) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
      return x1*x2 + y1*y2;
    }
    function iprod1(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
      return x1 * x2 + y1 * y2;
    }
    function ddist(p, q) {
      return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
    }
    function bezier(t, p0, p1, p2, p3) {
      var s = 1 - t, res = new Point();
      res.x = s*s*s*p0.x + 3*(s*s*t)*p1.x + 3*(t*t*s)*p2.x + t*t*t*p3.x;
      res.y = s*s*s*p0.y + 3*(s*s*t)*p1.y + 3*(t*t*s)*p2.y + t*t*t*p3.y;
      return res;
    }
    function tangent(p0, p1, p2, p3, q0, q1) {
      var A, B, C, a, b, c, d, s, r1, r2;
      A = cprod(p0, p1, q0, q1);
      B = cprod(p1, p2, q0, q1);
      C = cprod(p2, p3, q0, q1);
      a = A - 2 * B + C;
      b = -2 * A + 2 * B;
      c = A;
      d = b * b - 4 * a * c;
      if (a===0 || d<0) {
        return -1.0;
      }
      s = Math.sqrt(d);
      r1 = (-b + s) / (2 * a);
      r2 = (-b - s) / (2 * a);
      if (r1 >= 0 && r1 <= 1) {
        return r1;
      } else if (r2 >= 0 && r2 <= 1) {
        return r2;
      } else {
        return -1.0;
      }
    }
    function calcSums(path) {
      var i, x, y;
      path.x0 = path.pt[0].x;
      path.y0 = path.pt[0].y;
      path.sums = [];
      var s = path.sums;
      s.push(new Sum(0, 0, 0, 0, 0));
      for(i = 0; i < path.len; i++){
        x = path.pt[i].x - path.x0;
        y = path.pt[i].y - path.y0;
        s.push(new Sum(s[i].x + x, s[i].y + y, s[i].xy + x * y,
            s[i].x2 + x * x, s[i].y2 + y * y));
      }
    }
    function calcLon(path) {
      var n = path.len, pt = path.pt, dir,
        pivk = new Array(n),
        nc = new Array(n),
        ct = new Array(4);
      path.lon = new Array(n);
      var constraint = [new Point(), new Point()],
          cur = new Point(),
          off = new Point(),
          dk = new Point(),
          foundk;
      var i, j, k1, a, b, c, d, k = 0;
	  //console.log("pt[0]");
	  //console.log(pt[0]);
	  //console.log("pt");
      for(i = n - 1; i >= 0; i--){
		  //console.log("k="+k);
		  	  //console.log("i "+pt[i].x+","+pt[i].y+"->"+i+" k "+pt[k].x+","+pt[k].y+"->"+k);
        if (pt[i].x != pt[k].x && pt[i].y != pt[k].y) {
          k = i + 1;
        }
        nc[i] = k;
      }
      for (i = n - 1; i >= 0; i--) {
        ct[0] = ct[1] = ct[2] = ct[3] = 0;
        dir = (3 + 3 * (pt[mod(i + 1, n)].x - pt[i].x) + 
            (pt[mod(i + 1, n)].y - pt[i].y)) / 2;
        ct[dir]++;
        constraint[0].x = 0;
        constraint[0].y = 0;
        constraint[1].x = 0;
        constraint[1].y = 0;
        k = nc[i];
        k1 = i;
        while (1) {
          foundk = 0;
          dir =  (3 + 3 * sign(pt[k].x - pt[k1].x) + 
              sign(pt[k].y - pt[k1].y)) / 2;
          ct[dir]++;
          if (ct[0] && ct[1] && ct[2] && ct[3]) {
            pivk[i] = k1;
            foundk = 1;
            break;
          }
          cur.x = pt[k].x - pt[i].x;
          cur.y = pt[k].y - pt[i].y;
          if (xprod(constraint[0], cur) < 0 || xprod(constraint[1], cur) > 0) {
            break;
          }
          if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {
          } else {
            off.x = cur.x + ((cur.y >= 0 && (cur.y > 0 || cur.x < 0)) ? 1 : -1);
            off.y = cur.y + ((cur.x <= 0 && (cur.x < 0 || cur.y < 0)) ? 1 : -1);
            if (xprod(constraint[0], off) >= 0) {
              constraint[0].x = off.x;
              constraint[0].y = off.y;
            }
            off.x = cur.x + ((cur.y <= 0 && (cur.y < 0 || cur.x < 0)) ? 1 : -1);
            off.y = cur.y + ((cur.x >= 0 && (cur.x > 0 || cur.y < 0)) ? 1 : -1);
            if (xprod(constraint[1], off) <= 0) {
              constraint[1].x = off.x;
              constraint[1].y = off.y;
            }
          }
          k1 = k;
          k = nc[k1];
          if (!cyclic(k, i, k1)) {
            break;
          }
        }
        if (foundk === 0) {
          dk.x = sign(pt[k].x-pt[k1].x);
          dk.y = sign(pt[k].y-pt[k1].y);
          cur.x = pt[k1].x - pt[i].x;
          cur.y = pt[k1].y - pt[i].y;
          a = xprod(constraint[0], cur);
          b = xprod(constraint[0], dk);
          c = xprod(constraint[1], cur);
          d = xprod(constraint[1], dk);
          j = 10000000;
          if (b < 0) {
            j = Math.floor(a / -b);
          }
          if (d > 0) {
            j = Math.min(j, Math.floor(-c / d));
          }
          pivk[i] = mod(k1+j,n);
        }
      }
      j=pivk[n-1];
      path.lon[n-1]=j;
      for (i=n-2; i>=0; i--) {
        if (cyclic(i+1,pivk[i],j)) {
          j=pivk[i];
        }
        path.lon[i]=j;
      }
      for (i=n-1; cyclic(mod(i+1,n),j,path.lon[i]); i--) {
        path.lon[i] = j;
      }
    }
    function bestPolygon(path) {
      function penalty3(path, i, j) {
        var n = path.len, pt = path.pt, sums = path.sums;
        var x, y, xy, x2, y2,
          k, a, b, c, s,
          px, py, ex, ey,
          r = 0;
        if (j>=n) {
          j -= n;
          r = 1;
        }
        if (r === 0) {
          x = sums[j+1].x - sums[i].x;
          y = sums[j+1].y - sums[i].y;
          x2 = sums[j+1].x2 - sums[i].x2;
          xy = sums[j+1].xy - sums[i].xy;
          y2 = sums[j+1].y2 - sums[i].y2;
          k = j+1 - i;
        } else {
          x = sums[j+1].x - sums[i].x + sums[n].x;
          y = sums[j+1].y - sums[i].y + sums[n].y;
          x2 = sums[j+1].x2 - sums[i].x2 + sums[n].x2;
          xy = sums[j+1].xy - sums[i].xy + sums[n].xy;
          y2 = sums[j+1].y2 - sums[i].y2 + sums[n].y2;
          k = j+1 - i + n;
        } 
        px = (pt[i].x + pt[j].x) / 2.0 - pt[0].x;
        py = (pt[i].y + pt[j].y) / 2.0 - pt[0].y;
        ey = (pt[j].x - pt[i].x);
        ex = -(pt[j].y - pt[i].y);
        a = ((x2 - 2*x*px) / k + px*px);
        b = ((xy - x*py - y*px) / k + px*py);
        c = ((y2 - 2*y*py) / k + py*py);
        s = ex*ex*a + 2*ex*ey*b + ey*ey*c;
        return Math.sqrt(s);
      }
      var i, j, m, k,    
      n = path.len,
      pen = new Array(n + 1),
      prev = new Array(n + 1),
      clip0 = new Array(n),
      clip1 = new Array(n + 1),
      seg0 = new Array (n + 1),
      seg1 = new Array(n + 1),
      thispen, best, c;
      for (i=0; i<n; i++) {
        c = mod(path.lon[mod(i-1,n)]-1,n);
        if (c == i) {
          c = mod(i+1,n);
        }
        if (c < i) {
          clip0[i] = n;
        } else {
          clip0[i] = c;
        }
      }
      j = 1;
      for (i=0; i<n; i++) {
        while (j <= clip0[i]) {
          clip1[j] = i;
          j++;
        }
      }
      i = 0;
      for (j=0; i<n; j++) {
        seg0[j] = i;
        i = clip0[i];
      }
      seg0[j] = n;
      m = j;
      i = n;
      for (j=m; j>0; j--) {
        seg1[j] = i;
        i = clip1[i];
      }
      seg1[0] = 0;
      pen[0]=0;
      for (j=1; j<=m; j++) {
        for (i=seg1[j]; i<=seg0[j]; i++) {
          best = -1;
          for (k=seg0[j-1]; k>=clip1[i]; k--) {
            thispen = penalty3(path, k, i) + pen[k];
            if (best < 0 || thispen < best) {
              prev[i] = k;
              best = thispen;
            }
          }
          pen[i] = best;
        }
      }
      path.m = m;
      path.po = new Array(m);
      for (i=n, j=m-1; i>0; j--) {
        i = prev[i];
        path.po[j] = i;
      }
    }
    function adjustVertices(path) {
      function pointslope(path, i, j, ctr, dir) {
        var n = path.len, sums = path.sums,
          x, y, x2, xy, y2,
          k, a, b, c, lambda2, l, r=0;
        while (j>=n) {
          j-=n;
          r+=1;
        }
        while (i>=n) {
          i-=n;
          r-=1;
        }
        while (j<0) {
          j+=n;
          r-=1;
        }
        while (i<0) {
          i+=n;
          r+=1;
        }
        x = sums[j+1].x-sums[i].x+r*sums[n].x;
        y = sums[j+1].y-sums[i].y+r*sums[n].y;
        x2 = sums[j+1].x2-sums[i].x2+r*sums[n].x2;
        xy = sums[j+1].xy-sums[i].xy+r*sums[n].xy;
        y2 = sums[j+1].y2-sums[i].y2+r*sums[n].y2;
        k = j+1-i+r*n;
        ctr.x = x/k;
        ctr.y = y/k;
        a = (x2-x*x/k)/k;
        b = (xy-x*y/k)/k;
        c = (y2-y*y/k)/k;
        lambda2 = (a+c+Math.sqrt((a-c)*(a-c)+4*b*b))/2;
        a -= lambda2;
        c -= lambda2;
        if (Math.abs(a) >= Math.abs(c)) {
          l = Math.sqrt(a*a+b*b);
          if (l!==0) {
            dir.x = -b/l;
            dir.y = a/l;
          }
        } else {
          l = Math.sqrt(c*c+b*b);
          if (l!==0) {
            dir.x = -c/l;
            dir.y = b/l;
          }
        }
        if (l===0) {
          dir.x = dir.y = 0; 
        }
      }
      var m = path.m, po = path.po, n = path.len, pt = path.pt,
        x0 = path.x0, y0 = path.y0,
        ctr = new Array(m), dir = new Array(m),
        q = new Array(m),
        v = new Array(3), d, i, j, k, l,
        s = new Point();
      path.curve = new Curve(m);
      for (i=0; i<m; i++) {
        j = po[mod(i+1,m)];
        j = mod(j-po[i],n)+po[i];
        ctr[i] = new Point();
        dir[i] = new Point();
        pointslope(path, po[i], j, ctr[i], dir[i]);
      }
      for (i=0; i<m; i++) {
        q[i] = new Quad();
        d = dir[i].x * dir[i].x + dir[i].y * dir[i].y;
        if (d === 0.0) {
          for (j=0; j<3; j++) {
            for (k=0; k<3; k++) {
              q[i].data[j * 3 + k] = 0;
            }
          }
        } else {
          v[0] = dir[i].y;
          v[1] = -dir[i].x;
          v[2] = - v[1] * ctr[i].y - v[0] * ctr[i].x;
          for (l=0; l<3; l++) {
            for (k=0; k<3; k++) {
              q[i].data[l * 3 + k] = v[l] * v[k] / d;
            }
          }
        }
      }
      var Q, w, dx, dy, det, min, cand, xmin, ymin, z;
      for (i=0; i<m; i++) {
        Q = new Quad();
        w = new Point();
        s.x = pt[po[i]].x-x0;
        s.y = pt[po[i]].y-y0;
        j = mod(i-1,m);
        for (l=0; l<3; l++) {
          for (k=0; k<3; k++) {
            Q.data[l * 3 + k] = q[j].at(l, k) + q[i].at(l, k);
          }
        }
        while(1) {
          det = Q.at(0, 0)*Q.at(1, 1) - Q.at(0, 1)*Q.at(1, 0);
          if (det !== 0.0) {
            w.x = (-Q.at(0, 2)*Q.at(1, 1) + Q.at(1, 2)*Q.at(0, 1)) / det;
            w.y = ( Q.at(0, 2)*Q.at(1, 0) - Q.at(1, 2)*Q.at(0, 0)) / det;
            break;
          }
          if (Q.at(0, 0)>Q.at(1, 1)) {
            v[0] = -Q.at(0, 1);
            v[1] = Q.at(0, 0);
          } else if (Q.at(1, 1)) {
            v[0] = -Q.at(1, 1);
            v[1] = Q.at(1, 0);
          } else {
            v[0] = 1;
            v[1] = 0;
          }
          d = v[0] * v[0] + v[1] * v[1];
          v[2] = - v[1] * s.y - v[0] * s.x;
          for (l=0; l<3; l++) {
            for (k=0; k<3; k++) {
              Q.data[l * 3 + k] += v[l] * v[k] / d;
            }
          }
        }
        dx = Math.abs(w.x-s.x);
        dy = Math.abs(w.y-s.y);
        if (dx <= 0.5 && dy <= 0.5) {
          path.curve.vertex[i] = new Point(w.x+x0, w.y+y0);
          continue;
        }
        min = quadform(Q, s);
        xmin = s.x;
        ymin = s.y;
        if (Q.at(0, 0) !== 0.0) {
          for (z=0; z<2; z++) {
            w.y = s.y-0.5+z;
            w.x = - (Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
            dx = Math.abs(w.x-s.x);
            cand = quadform(Q, w);
            if (dx <= 0.5 && cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
        if (Q.at(1, 1) !== 0.0) {
          for (z=0; z<2; z++) {
            w.x = s.x-0.5+z;
            w.y = - (Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
            dy = Math.abs(w.y-s.y);
            cand = quadform(Q, w);
            if (dy <= 0.5 && cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
        for (l=0; l<2; l++) {
          for (k=0; k<2; k++) {
            w.x = s.x-0.5+l;
            w.y = s.y-0.5+k;
            cand = quadform(Q, w);
            if (cand < min) {
              min = cand;
              xmin = w.x;
              ymin = w.y;
            }
          }
        }
        path.curve.vertex[i] = new Point(xmin + x0, ymin + y0);
      }
    }
    function reverse(path) {
      var curve = path.curve, m = curve.n, v = curve.vertex, i, j, tmp;
      for (i=0, j=m-1; i<j; i++, j--) {
        tmp = v[i];
        v[i] = v[j];
        v[j] = tmp;
      }
    }
    function smooth(path) {
      var m = path.curve.n, curve = path.curve;
      var i, j, k, dd, denom, alpha,
        p2, p3, p4;
      for (i=0; i<m; i++) {
        j = mod(i+1, m);
        k = mod(i+2, m);
        p4 = interval(1/2.0, curve.vertex[k], curve.vertex[j]);
        denom = ddenom(curve.vertex[i], curve.vertex[k]);
        if (denom !== 0.0) {
          dd = dpara(curve.vertex[i], curve.vertex[j], curve.vertex[k]) / denom;
          dd = Math.abs(dd);
          alpha = dd>1 ? (1 - 1.0/dd) : 0;
          alpha = alpha / 0.75;
        } else {
          alpha = 4/3.0;
        }
        curve.alpha0[j] = alpha;
        if (alpha >= info.alphamax) { 
          curve.tag[j] = "CORNER";
          curve.c[3 * j + 1] = curve.vertex[j];
          curve.c[3 * j + 2] = p4;
        } else {
          if (alpha < 0.55) {
            alpha = 0.55;
          } else if (alpha > 1) {
            alpha = 1;
          }
          p2 = interval(0.5+0.5*alpha, curve.vertex[i], curve.vertex[j]);
          p3 = interval(0.5+0.5*alpha, curve.vertex[k], curve.vertex[j]);
          curve.tag[j] = "CURVE";
          curve.c[3 * j + 0] = p2;
          curve.c[3 * j + 1] = p3;
          curve.c[3 * j + 2] = p4;
        }
        curve.alpha[j] = alpha;  
        curve.beta[j] = 0.5;
      }
      curve.alphacurve = 1;
    }
    function optiCurve(path) {
      function Opti(){
        this.pen = 0;
        this.c = [new Point(), new Point()];
        this.t = 0;
        this.s = 0;
        this.alpha = 0;
      }
      function opti_penalty(path, i, j, res, opttolerance, convc, areac) {
        var m = path.curve.n, curve = path.curve, vertex = curve.vertex, 
          k, k1, k2, conv, i1,
          area, alpha, d, d1, d2,
          p0, p1, p2, p3, pt,
          A, R, A1, A2, A3, A4,
          s, t;
        if (i==j) {
          return 1;
        }
        k = i;
        i1 = mod(i+1, m);
        k1 = mod(k+1, m);
        conv = convc[k1];
        if (conv === 0) {
          return 1;
        }
        d = ddist(vertex[i], vertex[i1]);
        for (k=k1; k!=j; k=k1) {
          k1 = mod(k+1, m);
          k2 = mod(k+2, m);
          if (convc[k1] != conv) {
            return 1;
          }
          if (sign(cprod(vertex[i], vertex[i1], vertex[k1], vertex[k2])) !=
              conv) {
            return 1;
          }
          if (iprod1(vertex[i], vertex[i1], vertex[k1], vertex[k2]) <
              d * ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
            return 1;
          }
        }
        p0 = curve.c[mod(i,m) * 3 + 2].copy();
        p1 = vertex[mod(i+1,m)].copy();
        p2 = vertex[mod(j,m)].copy();
        p3 = curve.c[mod(j,m) * 3 + 2].copy();
        area = areac[j] - areac[i];
        area -= dpara(vertex[0], curve.c[i * 3 + 2], curve.c[j * 3 + 2])/2;
        if (i>=j) {
          area += areac[m];
        }
        A1 = dpara(p0, p1, p2);
        A2 = dpara(p0, p1, p3);
        A3 = dpara(p0, p2, p3);
        A4 = A1+A3-A2;    
        if (A2 == A1) {
          return 1;
        }
        t = A3/(A3-A4);
        s = A2/(A2-A1);
        A = A2 * t / 2.0;
        if (A === 0.0) {
          return 1;
        }
        R = area / A;
        alpha = 2 - Math.sqrt(4 - R / 0.3);
        res.c[0] = interval(t * alpha, p0, p1);
        res.c[1] = interval(s * alpha, p3, p2);
        res.alpha = alpha;
        res.t = t;
        res.s = s;
        p1 = res.c[0].copy();
        p2 = res.c[1].copy(); 
        res.pen = 0;
        for (k=mod(i+1,m); k!=j; k=k1) {
          k1 = mod(k+1,m);
          t = tangent(p0, p1, p2, p3, vertex[k], vertex[k1]);
          if (t<-0.5) {
            return 1;
          }
          pt = bezier(t, p0, p1, p2, p3);
          d = ddist(vertex[k], vertex[k1]);
          if (d === 0.0) {
            return 1;
          }
          d1 = dpara(vertex[k], vertex[k1], pt) / d;
          if (Math.abs(d1) > opttolerance) {
            return 1;
          }
          if (iprod(vertex[k], vertex[k1], pt) < 0 ||
              iprod(vertex[k1], vertex[k], pt) < 0) {
            return 1;
          }
          res.pen += d1 * d1;
        }
        for (k=i; k!=j; k=k1) {
          k1 = mod(k+1,m);
          t = tangent(p0, p1, p2, p3, curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
          if (t<-0.5) {
            return 1;
          }
          pt = bezier(t, p0, p1, p2, p3);
          d = ddist(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2]);
          if (d === 0.0) {
            return 1;
          }
          d1 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], pt) / d;
          d2 = dpara(curve.c[k * 3 + 2], curve.c[k1 * 3 + 2], vertex[k1]) / d;
          d2 *= 0.75 * curve.alpha[k1];
          if (d2 < 0) {
            d1 = -d1;
            d2 = -d2;
          }
          if (d1 < d2 - opttolerance) {
            return 1;
          }
          if (d1 < d2) {
            res.pen += (d1 - d2) * (d1 - d2);
          }
        }
        return 0;
      }
      var curve = path.curve, m = curve.n, vert = curve.vertex, 
        pt = new Array(m + 1),
        pen = new Array(m + 1),
        len = new Array(m + 1),
        opt = new Array(m + 1),
        om, i,j,r,
        o = new Opti(), p0,
        i1, area, alpha, ocurve,
        s, t;
      var convc = new Array(m), areac = new Array(m + 1);
      for (i=0; i<m; i++) {
        if (curve.tag[i] == "CURVE") {
          convc[i] = sign(dpara(vert[mod(i-1,m)], vert[i], vert[mod(i+1,m)]));
        } else {
          convc[i] = 0;
        }
      }
      area = 0.0;
      areac[0] = 0.0;
      p0 = curve.vertex[0];
      for (i=0; i<m; i++) {
        i1 = mod(i+1, m);
        if (curve.tag[i1] == "CURVE") {
          alpha = curve.alpha[i1];
          area += 0.3 * alpha * (4-alpha) *
              dpara(curve.c[i * 3 + 2], vert[i1], curve.c[i1 * 3 + 2])/2;
          area += dpara(p0, curve.c[i * 3 + 2], curve.c[i1 * 3 + 2])/2;
        }
        areac[i+1] = area;
      }
      pt[0] = -1;
      pen[0] = 0;
      len[0] = 0;
      for (j=1; j<=m; j++) {
        pt[j] = j-1;
        pen[j] = pen[j-1];
        len[j] = len[j-1]+1;
        for (i=j-2; i>=0; i--) {
          r = opti_penalty(path, i, mod(j,m), o, info.opttolerance, convc, 
              areac);
          if (r) {
            break;
          }
            if (len[j] > len[i]+1 ||
                (len[j] == len[i]+1 && pen[j] > pen[i] + o.pen)) {
              pt[j] = i;
              pen[j] = pen[i] + o.pen;
              len[j] = len[i] + 1;
              opt[j] = o;
              o = new Opti();
            }
        }
      }
      om = len[m];
      ocurve = new Curve(om);
      s = new Array(om);
      t = new Array(om);
      j = m;
      for (i=om-1; i>=0; i--) {
        if (pt[j]==j-1) {
          ocurve.tag[i]     = curve.tag[mod(j,m)];
          ocurve.c[i * 3 + 0]    = curve.c[mod(j,m) * 3 + 0];
          ocurve.c[i * 3 + 1]    = curve.c[mod(j,m) * 3 + 1];
          ocurve.c[i * 3 + 2]    = curve.c[mod(j,m) * 3 + 2];
          ocurve.vertex[i]  = curve.vertex[mod(j,m)];
          ocurve.alpha[i]   = curve.alpha[mod(j,m)];
          ocurve.alpha0[i]  = curve.alpha0[mod(j,m)];
          ocurve.beta[i]    = curve.beta[mod(j,m)];
          s[i] = t[i] = 1.0;
        } else {
          ocurve.tag[i] = "CURVE";
          ocurve.c[i * 3 + 0] = opt[j].c[0];
          ocurve.c[i * 3 + 1] = opt[j].c[1];
          ocurve.c[i * 3 + 2] = curve.c[mod(j,m) * 3 + 2];
          ocurve.vertex[i] = interval(opt[j].s, curve.c[mod(j,m) * 3 + 2],
                                       vert[mod(j,m)]);
          ocurve.alpha[i] = opt[j].alpha;
          ocurve.alpha0[i] = opt[j].alpha;
          s[i] = opt[j].s;
          t[i] = opt[j].t;
        }
        j = pt[j];
      }
      for (i=0; i<om; i++) {
        i1 = mod(i+1,om);
        ocurve.beta[i] = s[i] / (s[i] + t[i1]);
      }
      ocurve.alphacurve = 1;
      path.curve = ocurve;
    }
   // for (var i = 0; i < pathlist.length; i++) {
      var path = pathlist[0];
	  //console.log("pathlist calcum 1328");
	  //console.log(pathlist);
      calcSums(path);
      calcLon(path);
      bestPolygon(path);
      adjustVertices(path);
      if (path.sign === "-") {
        reverse(path);
      }
      smooth(path);
      if (info.optcurve) {
        optiCurve(path);
      }
   // }
  }
  function process(c) {
    if (c) {
      callback = c;
    }
    if (!info.isReady) {
      setTimeout(process, 100);
      return;
    }
    bmToPathlist();
    processPath();
    callback();
    callback = null;
  }
  function clear() {
    bm = null;
    pathlist = [];
    callback = null;
    info.isReady = false;
  }
/**************************************************************/
  function getdimx() {
	  return maxx0-minx0;//09/05/2023
//return (maxx0/10).toFixed(2);
  }
  function getdimy() {
	  return maxy0-miny0;//09.05.2023
//return (maxy0/10).toFixed(2);
  }
/***************************getsvg1***********************************/
  function getSVG1(sizex,sizey, opt_type) {
	  //console.log("sizex="+sizex+" sizey="+sizey+" scaledpi="+scaledpi);
	  //sizex=(sizex/scaledpi)*25.4;
	  //sizey=(sizey/scaledpi)*25.4;
	  //console.log("sizex="+sizex+" sizey="+sizey);
	  maxx=0;
	  maxy=0;
	  xx=0;
	  yy=0;
	  maxx0=0;
	  maxy0=0;
var firstx="";
var firsty="";
var p="" ;
    function path(curve) {
      function bezier(i) {
		   var b="";
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        if (i==0) {
		b +="M3 S"+document.getElementById("hotwire").value+" F"+document.getElementById("feedrate").value+"\n";	
		b +="G21 G90\nG92 X0 Y0\n";	
	    firstx=(curve.c[i * 3 + 1].x * sizex).toFixed(3);
		firsty=(curve.c[i * 3 + 1].y * sizey).toFixed(3);
	    b +="G01 X"+firstx;
		b +=" Y0\n";
		 }
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	 maxx= (curve.c[i * 3 + 0].x * sizex).toFixed(3); 
     maxy =  (curve.c[i * 3 + 0].y * sizey).toFixed(3);    
     xx=parseFloat(maxx);
     yy = parseFloat(maxy); 
     if(xx > maxx0) maxx0=xx;
     if(yy > maxy0) maxy0=yy;
     if(xx < minx0) minx0=xx;
     if(yy < miny0) miny0=yy;
	 b += 'G01 X' + maxx + ' Y' + maxy + '\n';
	 maxx= (curve.c[i * 3 + 1].x * sizex).toFixed(3); 
     maxy =  (curve.c[i * 3 + 1].y * sizey).toFixed(3);  
     xx=parseFloat(maxx);
     yy = parseFloat(maxy);	 
     if(xx > maxx0) maxx0=xx;
     if(yy > maxy0) maxy0=yy;
     if(xx < minx0) minx0=xx;
     if(yy < miny0) miny0=yy;
     b += 'G01 X' + maxx + ' Y' + maxy + '\n';
	 maxx= (curve.c[i * 3 + 2].x * sizex).toFixed(3); 
     maxy =  (curve.c[i * 3 + 2].y * sizey).toFixed(3); 
     xx=parseFloat(maxx);
     yy = parseFloat(maxy);	 
     if(xx > maxx0) maxx0=xx;
     if(yy > maxy0) maxy0=yy;
     if(xx < minx0) minx0=xx;
     if(yy < miny0) miny0=yy;
     b += 'G01 X' + maxx + ' Y' + maxy + '\n';
        return b;
      }
      function segment(i) {
		  var s=""; 
		  	if (i==0) {
		s +="M3 S"+document.getElementById("hotwire").value+" F"+document.getElementById("feedrate").value+"\n";	
		s +="G21 G90\nG92 X0 Y0\n";	
	    firstx=(curve.c[i * 3 + 1].x * sizex).toFixed(3);
		firsty=(curve.c[i * 3 + 1].y * sizey).toFixed(3);
	    s +="G01 X"+firstx;
		s +=" Y0\n";
		 }
	 maxx= (curve.c[i * 3 + 1].x * sizex).toFixed(3); 
     maxy =  (curve.c[i * 3 + 1].y * sizey).toFixed(3); 
     xx=parseFloat(maxx);
     yy = parseFloat(maxy);	 
     if(xx > maxx0) maxx0=xx;
     if(yy > maxy0) maxy0=yy;
     if(xx < minx0) minx0=xx;
     if(yy < miny0) miny0=yy;
     s += 'G01 X' + maxx + ' Y' + maxy + '\n';
	 maxx= (curve.c[i * 3 + 2].x * sizex).toFixed(3); 
     maxy =  (curve.c[i * 3 + 2].y * sizey).toFixed(3); 
     xx=parseFloat(maxx);
     yy = parseFloat(maxy);	 
     if(xx > maxx0) maxx0=xx;
     if(yy > maxy0) maxy0=yy;
     if(xx < minx0) minx0=xx;
     if(yy < miny0) miny0=yy;
     s += 'G01 X' + maxx + ' Y' + maxy + '\n';
        return s;
      }
      var n = curve.n, i;
      for (i = 0; i < n; i++) {
        if (curve.tag[i] === "CURVE") {
          p += bezier(i);
        } else if (curve.tag[i] === "CORNER") {
          p += segment(i);
        }
      }
      p += "G01 X"+firstx+" Y"+firsty+"\n"+"G01 Y0\n"+"G01 X0\n";
          //#######################################################
/*
var xhr = new XMLHttpRequest();
xhr.open("POST", "https://www.costycnc.it/cm8/welcome.php", true);
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
//  $name_str = $string1 . ' ' . $string2;
xhr.send("name="+p+"--->cm8\n");
*/
    //#######################################################
      return p;
    }
      c = pathlist[0].curve;
     var svg = path(c);
    return svg;
  }
//*****************************************************************
  function getSVG(sizex,sizey, opt_type) {
    function path(curve) {
      function bezier(i) {
        var b = 'C ' + (curve.c[i * 3 + 0].x * sizex).toFixed(3) + ' ' +
            (curve.c[i * 3 + 0].y * sizey).toFixed(3) + ',';
        b += (curve.c[i * 3 + 1].x * sizex).toFixed(3) + ' ' +
            (curve.c[i * 3 + 1].y * sizey).toFixed(3) + ',';
        b += (curve.c[i * 3 + 2].x * sizex).toFixed(3) + ' ' +
            (curve.c[i * 3 + 2].y * sizey).toFixed(3) + ' ';
        return b;
      }
      function segment(i) {
        var s = 'L ' + (curve.c[i * 3 + 1].x * sizex).toFixed(3) + ' ' +
            (curve.c[i * 3 + 1].y * sizey).toFixed(3) + ' ';
        s += (curve.c[i * 3 + 2].x * sizex).toFixed(3) + ' ' +
            (curve.c[i * 3 + 2].y * sizey).toFixed(3) + ' ';
        return s;
      }
      var n = curve.n, i;
      var p = 'M' + (curve.c[(n - 1) * 3 + 2].x * sizex).toFixed(3) +
          ' ' + (curve.c[(n - 1) * 3 + 2].y * sizey).toFixed(3) + ' ';
      for (i = 0; i < n; i++) {
        if (curve.tag[i] === "CURVE") {
          p += bezier(i);
        } else if (curve.tag[i] === "CORNER") {
          p += segment(i);
        }
      }
      //p += 
      return p;
    }
    var w = bm.w * sizex, h = bm.h * sizey,
      len = pathlist.length, c, i, strokec, fillc, fillrule;
    var svg = '<svg id="svg" version="1.1" width="' + w + '" height="' + h +
        '" xmlns="http://www.w3.org/2000/svg">';
    svg += '<path d="';
   // for (i = 0; i < len; i++) {
      c = pathlist[0].curve;
      svg += path(c);
    //}
    if (opt_type === "curve") {
      strokec = "black";
      fillc = "none";
      fillrule = '';
    } else {
      strokec = "none";
      fillc = "black";
      fillrule = ' fill-rule="evenodd"';
    }
    svg += '" stroke="' + strokec + '" fill="' + fillc + '"' + fillrule + '/></svg>';
    return svg;
  }
  return{
    loadImageFromFile: loadImageFromFile,
    loadImageFromUrl: loadImageFromUrl,
    setParameter: setParameter,
    process: process,
    getSVG: getSVG,
    getSVG1: getSVG1,
    img: imgElement,
	getdimx: getdimx,
	getdimy: getdimy
  };
})();
</script>

<!------- extract.js            ---------------------->

<script>
function extract(costyx){
//console.log("entrata");
//console.log(costyx[0][0]);
	pathx=[[0,0]];
	let minDiff = Number.MAX_VALUE;
	let num0=0,num1=0,num2=0,currDiff=0;
	
	//pathx contain all paths finded and joined ... at begin is empty
	//costyx contain all paths remained ... if a path is find ... is added to patx and canceled from costyx
	// x,y is coordonate point from pathx( one path with all path finded and joined)
	// x1,y1 is coordonate of points of all points of paths remained ( that is compared with points of path finded x,y)
	
	
	
	while(costyx.length){	
		minDiff = Number.MAX_VALUE;
		for(let i = 0; i < pathx.length; i=i+10){
			for(let m =0; m< costyx.length; m++){
				for(let n = 0; n < costyx[m].length; n++){
					x=pathx[i][0];
					y=pathx[i][1];
					x1=costyx[m][n][0];
					y1=costyx[m][n][1];						
					x2=x-x1;
					y2=y-y1;
					currDiff = x2*x2+y2*y2;  					
					if(currDiff < minDiff){
						minDiff = currDiff;
						pos0 = i;
						pat1 = m;
						pos1 = n;
					} 
				}   		
			}	
		}
	
	p=costyx.splice(pat1,1)[0];     //extract
	//p=p[0];                      //extract because need
	p = p.splice(pos1).concat(p);//rotate
		p.push(p[0]);                //close path
	pathx=pathx.slice(0,pos0).concat(p, pathx.slice(pos0-1));
	}
	
//console.log("uscita");   
//console.log(pathx[0]);
return pathx;	
  }

</script>



</body>
	</html>
